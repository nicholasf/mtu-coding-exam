/// <reference types="node" />

// The default namespace contains the typing for QuickRoute.
interface Search {
    (apikey: string, query: string): Promise<Address[]>; // we need a non TomTom type here 
}

interface Address {
    streetNumber: string;
    streetName: string;
    municipalitySubdivision: string;
    municipality: string;
    countrySecondarySubdivision?: string;
    countryTertiarySubdivision?: string;
    countrySubdivision: string;
    postalCode: string;
    extendedPostalCode?: string;
    countryCode: string;
    country: string;
    countryCodeISO3: string;
    freeformAddress: string;
    countrySubdivisionName: string;
    localName: string;
}


// This namespace contains the information architecture for TomTom's api
// QuickRoute's types won't rely on TomTom's.
// The below was generated by copying and pasting the JSON response from TomTom's API documentation at 
// // https://developer.tomtom.com/search-api/documentation/search-service/fuzzy-search#response-data
// into Claude and asking it to produce matching interfaces, (except for the type alias on Address)
namespace TomTom {

    interface SearchResponse {
        summary: SearchSummary;
        results: SearchResult[];
    }

    interface GeoBias {
        lat: number;
        lon: number;
    }
    interface SearchSummary {
        query: string;
        queryType: string; // Could be "NON_NEAR" | "NEAR" | etc. if you know all possible values
        queryTime: number;
        numResults: number;
        offset: number;
        totalResults: number;
        fuzzyLevel: number;
        geoBias: GeoBias;
        queryIntent: any[]; // Replace with specific type if you know the structure
    }

    interface TimePoint {
        date: string;
        hour: number;
        minute: number;
    }

    interface TimeRange {
        startTime: TimePoint;
        endTime: TimePoint;
    }

    interface OpeningHours {
        mode: string;
        timeRanges: TimeRange[];
    }

    interface Brand {
        name: string;
    }

    interface CategorySet {
        id: number;
    }

    interface ClassificationName {
        nameLocale: string;
        name: string;
    }

    interface Classification {
        code: string;
        names: ClassificationName[];
    }

    interface TimeZone {
        ianaId: string;
    }

    interface POI {
        name: string;
        phone: string;
        url: string;
        brands: Brand[];
        categorySet: CategorySet[];
        categories: string[];
        openingHours: OpeningHours;
        classifications: Classification[];
        timeZone: TimeZone;
    }

    interface RelatedPoi {
        relationType: string;
        id: string;
    }

    type Address = Address; // Use the Address interface defined above

    interface Position {
        lat: number;
        lon: number;
    }

    interface Mapcode {
        type: string;
        fullMapcode: string;
        territory?: string;
        code?: string;
    }

    interface Viewport {
        topLeftPoint: Position;
        btmRightPoint: Position;
    }

    interface EntryPoint {
        type: string;
        position: Position;
        functions?: string[];
    }

    interface AddressRanges {
        rangeLeft: string;
        rangeRight: string;
        from: Position;
        to: Position;
    }

    interface Connector {
        connectorType: string;
        ratedPowerKW: number;
        currentA: number;
        currentType: string;
        voltageV: number;
    }

    interface ChargingPark {
        connectors: Connector[];
    }

    interface DataSource {
        id: string;
    }

    interface DataSources {
        chargingAvailability: DataSource;
        parkingAvailability: DataSource;
        fuelPrice: DataSource;
        geometry: DataSource;
    }

    interface SearchResult {
        type: string;
        id: string;
        score: number;
        dist: number;
        info: string;
        entityType: string;
        poi: POI;
        relatedPois: RelatedPoi[];
        address: Address;
        position: Position;
        mapcodes: Mapcode[];
        viewport: Viewport;
        entryPoints: EntryPoint[];
        addressRanges: AddressRanges;
        chargingPark: ChargingPark;
        dataSources: DataSources;
    }
}
